<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–ö–∞–ª–µ–Ω–¥–∞—Ä—å –ó–∞–ª–µ–∑–∞</title>

<script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isoWeek.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dayjs@1/locale/ru.js"></script>

<style>
:root {
    --bg: #121212;
    --card-bg: #1e1e1e;
    --accent: #bb86fc;
    --text: #e0e0e0;
    --border: #333;
    --success: #4caf50;
    --warning: #f5c542;
}

body {
    font-family: 'Segoe UI', sans-serif;
    background-color: var(--bg);
    color: var(--text);
    margin: 0;
    display: flex;
    justify-content: center;
    min-height: 100vh;
    user-select: none;
    -webkit-user-select: none;
}

img {
    user-select: none;
    -webkit-user-select: none;
    -webkit-user-drag: none;
}

.container {
    width: min(100%, 980px);
    padding: 12px;
}

header { text-align: center; margin-bottom: 12px; }

.profile-card {
    background: var(--card-bg);
    padding: 15px;
    border-radius: 12px;
    margin-bottom: 20px;
    border: 1px solid var(--border);
}

.profile-name-input {
    font-size: 1.2rem;
    padding: 12px;
}

input, select {
    user-select: text;
    -webkit-user-select: text;
    background: #2d2d2d;
    border: 1px solid var(--border);
    color: white;
    padding: 8px;
    border-radius: 6px;
    margin: 5px 0;
    width: 100%;
    box-sizing: border-box;
}

button {
    background: var(--accent);
    border: none;
    padding: 10px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
}

.icon-button {
    width: 36px;
    height: 36px;
    border-radius: 10px;
    background: #2a2a2a;
    color: #fff;
    border: 1px solid var(--border);
    padding: 0;
    display: grid;
    place-items: center;
    transition: transform 0.15s ease, border-color 0.15s ease, background 0.15s ease;
}

.icon-button:hover {
    transform: translateY(-1px);
    border-color: var(--accent);
    background: #343434;
}

.icon-button svg {
    width: 18px;
    height: 18px;
}

.calendar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

#monthTitle {
    transition: opacity 0.11s ease, transform 0.11s ease;
    opacity: 1;
    transform: translateX(0);
}

#monthTitle.animating {
    opacity: 0;
}

#monthTitle.slide-left.animating {
    transform: translateX(-8px);
}

#monthTitle.slide-right.animating {
    transform: translateX(8px);
}

.grid {
    display: grid;
    grid-template-columns: repeat(7, minmax(0, 1fr));
    gap: 4px;
    margin-top: 8px;
}

.calendar-wrap {
    transition: opacity 0.11s ease, transform 0.11s ease;
    opacity: 1;
    transform: translateX(0);
}

.calendar-wrap.animating {
    opacity: 0;
}

.calendar-wrap.slide-left.animating {
    transform: translateX(-8px);
}

.calendar-wrap.slide-right.animating {
    transform: translateX(8px);
}

.weekday {
    text-align: center;
    font-size: 0.8em;
    opacity: 0.6;
}

.day {
    min-height: clamp(64px, 11vw, 92px);
    background: var(--card-bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 5px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    transition: 0.2s;
}

.gym-icons {
    display: flex;
    flex-wrap: wrap;
    gap: 3px;
}

.gym-icon {
    width: 17px;
    height: 17px;
    border-radius: 50%;
    border: 1px solid rgba(255,255,255,0.15);
    overflow: hidden;
    background: #2d2d2d;
    display: inline-flex;
}

.gym-icon.is-new {
    animation: fade-scale-in 0.14s ease-out both;
}

.gym-icon img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}

.day:hover { border-color: var(--accent); }

.day.today {
    border-bottom: 3px solid var(--accent);
}

.day.has-events {
    border-color: var(--success);
}

.day.has-unsure-only {
    border-color: var(--warning);
}

.count {
    font-size: 0.75em;
    opacity: 0.8;
}

#modal, .overlay {
    position: fixed;
}

.overlay {
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.7);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.16s ease;
}

#modal {
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-bg);
    padding: 20px;
    border-radius: 15px;
    width: 300px;
    z-index: 10;
    opacity: 0;
    pointer-events: none;
    transform: translate(-50%, -45%) scale(0.97);
    transition: transform 0.16s ease, opacity 0.16s ease;
}

.overlay.open {
    opacity: 1;
    pointer-events: auto;
}

#modal.open {
    opacity: 1;
    pointer-events: auto;
    transform: translate(-50%, -50%) scale(1);
}

.visit-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
    padding: 3px 0;
    font-size: 0.94em;
}

.visit-text,
#modalDateTitle {
    user-select: text;
    -webkit-user-select: text;
}

.visit-item.is-new {
    animation: fade-scale-in 0.14s ease-out both;
}

.visit-item.uncertain {
    filter: none;
}

.visit-name.uncertain {
    opacity: 0.85;
}

.delete-btn {
    background: #b12e2e;
    color: #fff;
    padding: 5px 8px;
    font-size: 0.75em;
}

.success-message {
    color: var(--success);
    font-size: 0.85em;
}

#modal h3 {
    margin: 0 0 10px;
}

#visitsList {
    margin-bottom: 10px;
    display: grid;
    gap: 2px;
}

#modal hr {
    border: 0;
    border-top: 1px solid var(--border);
    margin: 10px 0 12px;
}

.modal-controls {
    display: grid;
    gap: 16px;
}

.uncertain-toggle {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    font-size: 0.92em;
    opacity: 0.95;
    user-select: none;
    padding: 2px 0;
}

.uncertain-checkbox {
    appearance: none;
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    margin: 0;
    border-radius: 5px;
    border: 1px solid #5a5a5a;
    background: #2a2a2a;
    display: inline-grid;
    place-items: center;
    position: relative;
    cursor: pointer;
    transition: border-color 0.14s ease, background-color 0.14s ease, transform 0.14s ease;
}

.uncertain-checkbox::before {
    content: '‚úì';
    position: absolute;
    top: 50%;
    left: 50%;
    font-size: 13px;
    line-height: 1;
    color: #121212;
    transform: translate(-50%, -50%) scale(0);
    transform-origin: center;
    transition: transform 0.14s ease;
}

.uncertain-checkbox:hover {
    border-color: var(--accent);
}

.uncertain-checkbox:checked {
    border-color: var(--accent);
    background: var(--accent);
}

.uncertain-checkbox:checked::before {
    transform: translate(-50%, -50%) scale(1);
}

.uncertain-checkbox:active {
    transform: scale(0.96);
}

@keyframes fade-scale-in {
    from {
        opacity: 0;
        transform: scale(0.985);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

#submitVisitButton {
    margin-top: 0;
    padding: 11px 10px;
}

.custom-select {
    position: relative;
}

.custom-select-trigger {
    width: 100%;
    background: #2d2d2d;
    border: 1px solid var(--border);
    color: #fff;
    padding: 11px 12px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-weight: 500;
}

.custom-select-trigger:hover {
    border-color: var(--accent);
}

.custom-select-menu {
    position: absolute;
    left: 0;
    right: 0;
    top: calc(100% + 6px);
    background: #242424;
    border: 1px solid var(--border);
    border-radius: 10px;
    max-height: 210px;
    overflow-y: auto;
    display: block;
    z-index: 12;
    padding: 4px;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    transform: translateY(-4px) scale(0.98);
    transform-origin: top center;
    transition: opacity 0.14s ease, transform 0.14s ease, visibility 0s linear 0.14s;
}

.custom-select.open .custom-select-menu {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    transform: translateY(0) scale(1);
    transition-delay: 0s;
}

#modal.interaction-locked .modal-controls,
#modal.interaction-locked #visitsList .delete-btn {
    pointer-events: none;
}

.custom-select-option {
    width: 100%;
    background: transparent;
    color: #fff;
    text-align: left;
    padding: 8px 10px;
    border-radius: 8px;
    font-weight: 400;
}

.custom-select-option:hover,
.custom-select-option.active {
    background: rgba(187, 134, 252, 0.2);
}

.custom-select-arrow {
    opacity: 0.8;
    font-size: 0.85em;
}
</style>
</head>

<body>

<div class="container">
<div class="profile-card">
<input type="text" id="userName" class="profile-name-input" placeholder="–ê–¥–∞–º –û–Ω–¥—Ä–∞">
</div>

<div class="calendar-header">
<button class="icon-button" onpointerdown="shiftMonthBy(-1)" aria-label="–ü—Ä–µ–¥—ã–¥—É—â–∏–π –º–µ—Å—è—Ü">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
</button>
<h2 id="monthTitle"></h2>
<button class="icon-button" onpointerdown="shiftMonthBy(1)" aria-label="–°–ª–µ–¥—É—é—â–∏–π –º–µ—Å—è—Ü">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
</button>
</div>

<div id="calendarWrap" class="calendar-wrap">
    <div id="calendar" class="grid"></div>
</div>

</div>

<div class="overlay" id="overlay"></div>

<div id="modal">
<h3 id="modalDateTitle"></h3>
<div id="visitsList"></div>
<hr>
<div class="modal-controls">
<div class="custom-select" id="gymSelectUi"></div>
<input type="hidden" id="gymSelect">
<div class="custom-select" id="visitTimeUi"></div>
<input type="hidden" id="visitTime">
<label class="uncertain-toggle" for="visitUncertain">
    <span>–ù–µ —É–≤–µ—Ä–µ–Ω</span>
    <input type="checkbox" id="visitUncertain" class="uncertain-checkbox">
</label>
<button id="submitVisitButton" onpointerdown="submitVisit()">–ó–∞–ø–∏—Å–∞—Ç—å—Å—è</button>
</div>
</div>

<script>
dayjs.extend(window.dayjs_plugin_isoWeek);
dayjs.locale('ru');

const API_URL = 'https://script.google.com/macros/s/AKfycbywsHJJz9FzGV3J3G_02MR1UAyTGdT6ldqVto82zJbSFF4C2snqAZWAH2q_kpaFbp0C/exec';

const state = {
    currentMonth: dayjs(),
    events: [],
    deletionShadows: [],
    selectedDate: '',
    previousCalendarGymsByDate: {},
    modalEventKeysByDate: {},
    modalUnlockTimeoutId: null,
    modalInteractionTimeoutId: null,
    modalInteractionToken: 0,
    modalInteractionUnlockedAt: 0
};
const EVENTS_CACHE_KEY = 'climbEventsCache';
const SYNC_INTERVAL_MS = 10_000;
const SHADOW_TTL_MS = 5_000;
const UTC_PLUS_3_OFFSET_MINUTES = 3 * 60;
const MODAL_INTERACTION_LOCK_MS = 300;
const UNSURE_MARK = ' (?)';

const gymMeta = {
    'Bigwall –î–∏–Ω–∞–º–æ': { image: 'icons/bigwall.png' },
    'Bigwall –ì–∞–≤–∞–Ω—å': { image: 'icons/bigwall.png' },
    'Bigwall –†–∏–≤—å–µ—Ä–∞': { image: 'icons/bigwall.png' },
    'ClimbLab –ë—É—Ç—ã—Ä—Å–∫–∞—è': { image: 'icons/climblab.jpg' },
    'ClimbLab –ê–º–∏–Ω—å–µ–≤—Å–∫–∞—è': { image: 'icons/climblab.jpg' },
    "Tengu's –ú–∏—á—É—Ä–∏–Ω—Å–∫–∏–π": { image: 'icons/tengus.png' },
    "Tengu's –Æ–∂–Ω–∞—è": { image: 'icons/tengus.png' },
    'Limestone': { image: 'icons/limestone.png' },
    'Rockzona': { image: 'icons/rockzona.png' },
    'Tokyo': { image: 'icons/tokyo.png' },
    '–¶–°–ö–ê': { image: 'icons/cska.png' }
};

const gymOptions = [
    'Bigwall –î–∏–Ω–∞–º–æ',
    'Bigwall –ì–∞–≤–∞–Ω—å',
    'Bigwall –†–∏–≤—å–µ—Ä–∞',
    'ClimbLab –ë—É—Ç—ã—Ä—Å–∫–∞—è',
    'ClimbLab –ê–º–∏–Ω—å–µ–≤—Å–∫–∞—è',
    "Tengu's –ú–∏—á—É—Ä–∏–Ω—Å–∫–∏–π",
    "Tengu's –Æ–∂–Ω–∞—è",
    'Limestone',
    'Rockzona',
    'Tokyo',
    '–¶–°–ö–ê'
];

const overlayElement = document.getElementById('overlay');
const modalElement = document.getElementById('modal');

document.getElementById('userName').value = localStorage.getItem('climberName') || '';
document.getElementById('userName').addEventListener('input', (e) => {
    localStorage.setItem('climberName', e.target.value.trim());
});
initializeModalControls();

// ===== Utilities =====
function escapeHtml(str) {
    return str.replace(/[&<>"']/g, m => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'
    }[m]));
}

function setEvents(nextEvents) {
    state.events = nextEvents;
}

function isModalOpen() {
    return modalElement.classList.contains('open');
}

function buildEventsByDateIndex(eventsList) {
    const byDate = new Map();
    eventsList.forEach(event => {
        if (!byDate.has(event.date)) byDate.set(event.date, []);
        byDate.get(event.date).push(event);
    });
    return byDate;
}

// ===== UI controls =====

function initializeModalControls() {
    renderCustomSelect({
        uiId: 'gymSelectUi',
        inputId: 'gymSelect',
        options: gymOptions,
        defaultValue: gymOptions[0],
        placeholder: '–í—ã–±–µ—Ä–∏ —Å–∫–∞–ª–æ–¥—Ä–æ–º'
    });

    const timeOptions = [];
    for (let hour = 0; hour < 24; hour++) {
        for (let minute = 0; minute < 60; minute += 15) {
            timeOptions.push(`${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`);
        }
    }

    renderCustomSelect({
        uiId: 'visitTimeUi',
        inputId: 'visitTime',
        options: timeOptions,
        defaultValue: '19:00',
        placeholder: '–í—ã–±–µ—Ä–∏ –≤—Ä–µ–º—è'
    });
}

function renderCustomSelect({ uiId, inputId, options, defaultValue, placeholder }) {
    const container = document.getElementById(uiId);
    const input = document.getElementById(inputId);
    input.value = defaultValue;

    container.innerHTML = `
        <button type="button" class="custom-select-trigger" data-role="trigger" aria-expanded="false">
            <span class="custom-select-value">${escapeHtml(defaultValue || placeholder)}</span>
            <span class="custom-select-arrow">‚ñæ</span>
        </button>
        <div class="custom-select-menu" data-role="menu"></div>
    `;

    const trigger = container.querySelector('[data-role="trigger"]');
    const valueNode = container.querySelector('.custom-select-value');
    const menu = container.querySelector('[data-role="menu"]');

    menu.innerHTML = options.map(option => `
        <button type="button" class="custom-select-option ${option === defaultValue ? 'active' : ''}" data-value="${escapeHtml(option)}">${escapeHtml(option)}</button>
    `).join('');

    trigger.addEventListener('pointerdown', (event) => {
        event.preventDefault();
        const isOpen = container.classList.contains('open');
        closeAllCustomSelects();
        if (!isOpen) {
            container.classList.add('open');
            trigger.setAttribute('aria-expanded', 'true');
            scrollActiveOptionIntoView(container);
        }
    });

    menu.addEventListener('click', (event) => {
        const optionButton = event.target.closest('.custom-select-option');
        if (!optionButton) return;
        const value = optionButton.getAttribute('data-value');
        input.value = value;
        valueNode.textContent = value;
        menu.querySelectorAll('.custom-select-option').forEach(item => item.classList.toggle('active', item === optionButton));
        closeAllCustomSelects();
    });
}

function setCustomSelectValue(uiId, inputId, value) {
    const container = document.getElementById(uiId);
    const input = document.getElementById(inputId);
    if (!container || !input || !value) return;

    const valueNode = container.querySelector('.custom-select-value');
    const options = container.querySelectorAll('.custom-select-option');

    let matchedOption = null;
    options.forEach(option => {
        const isMatch = option.getAttribute('data-value') === value;
        option.classList.toggle('active', isMatch);
        if (isMatch) matchedOption = option;
    });

    if (!matchedOption) return;

    input.value = value;
    if (valueNode) valueNode.textContent = value;
}

function closeAllCustomSelects() {
    document.querySelectorAll('.custom-select.open').forEach(select => {
        select.classList.remove('open');
        const trigger = select.querySelector('[data-role="trigger"]');
        if (trigger) trigger.setAttribute('aria-expanded', 'false');
    });
}

function scrollActiveOptionIntoView(container) {
    const menu = container.querySelector('[data-role="menu"]');
    const activeOption = container.querySelector('.custom-select-option.active');
    if (!menu || !activeOption) return;

    const optionTop = activeOption.offsetTop;
    const optionHeight = activeOption.offsetHeight;
    const targetScroll = optionTop - (menu.clientHeight / 2) + (optionHeight / 2);
    menu.scrollTop = Math.max(0, targetScroll);
}

document.addEventListener('pointerdown', (event) => {
    if (!event.target.closest('.custom-select')) {
        closeAllCustomSelects();
    }

});

overlayElement.addEventListener('click', (event) => {
    event.preventDefault();
    event.stopPropagation();
    if (isModalInteractionLocked()) return;
    closeModal({ deferUnlock: true });
});

overlayElement.addEventListener('pointerdown', (event) => {
    event.preventDefault();
    event.stopPropagation();
});

modalElement.addEventListener('pointerdown', (event) => {
    event.stopPropagation();
});

function isModalInteractionLocked() {
    return Date.now() < state.modalInteractionUnlockedAt;
}

function lockModalInteraction() {
    if (state.modalInteractionTimeoutId) {
        clearTimeout(state.modalInteractionTimeoutId);
        state.modalInteractionTimeoutId = null;
    }

    state.modalInteractionToken += 1;
    const token = state.modalInteractionToken;
    state.modalInteractionUnlockedAt = Date.now() + MODAL_INTERACTION_LOCK_MS;
    modalElement.classList.add('interaction-locked');
    state.modalInteractionTimeoutId = setTimeout(() => {
        if (token !== state.modalInteractionToken) return;
        modalElement.classList.remove('interaction-locked');
        state.modalInteractionTimeoutId = null;
    }, MODAL_INTERACTION_LOCK_MS);
}

// ===== Data normalization and API =====

async function fetchEventsSnapshot() {
    try {
        const res = await fetch(API_URL);
        const rawData = await res.json();
        return normalizeEvents(rawData);
    } catch (e) {
        return null;
    }

}

function normalizeEvents(rawData) {
    if (!Array.isArray(rawData)) return [];

    if (rawData.length > 0 && !Array.isArray(rawData[0])) {
        return rawData
            .filter(item => item && item.date && item.name)
            .map(item => {
                const parsed = parseUnsureFromName(item.name);
                return {
                    ...item,
                    date: normalizeDate(item.date),
                    name: parsed.name,
                    time: normalizeTime(item.time),
                    unsure: normalizeUnsure(item.unsure) || parsed.unsure,
                    row: item.row || item.id || null,
                    id: String(item.id || item.row || crypto.randomUUID())
                };
            })
            .map(withFingerprint)
            .filter(item => item.date);
    }

    return rawData
        .map((row, index) => ({ row, sourceRow: index + 1 }))
        .filter(({ row }) => Array.isArray(row) && row.length >= 4)
        .map(({ row, sourceRow }) => {
            const [date, name, gym, time, unsure] = row;
            const parsed = parseUnsureFromName(name);
            return {
                row: sourceRow,
                date: normalizeDate(date),
                name: parsed.name,
                gym: String(gym || ''),
                time: normalizeTime(time),
                unsure: normalizeUnsure(unsure) || parsed.unsure,
                id: String(sourceRow)
            };
        })
        .map(withFingerprint)
        .filter(item => item.date && item.name);
}

function parseUnsureFromName(nameValue) {
    const rawName = String(nameValue || '').trim();
    if (!rawName) return { name: '', unsure: false };
    if (!rawName.endsWith(UNSURE_MARK)) return { name: rawName, unsure: false };
    return {
        name: rawName.slice(0, -UNSURE_MARK.length).trim(),
        unsure: true
    };
}

function withFingerprint(item) {
    return {
        ...item,
        fingerprint: eventFingerprint(item)
    };
}

function eventFingerprint(item) {
    return [item.date || '', item.name || '', item.gym || '', item.time || '', item.unsure ? '1' : '0'].join('|');
}

function normalizeUnsure(value) {
    if (typeof value === 'boolean') return value;
    const raw = String(value || '').trim().toLowerCase();
    return raw === 'true' || raw === '1' || raw === '–¥–∞' || raw === 'yes';
}

function normalizeDate(input) {
    if (!input) return '';
    const raw = String(input).trim();
    if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return raw;

    if (looksLikeDateTime(raw)) {
        const parsed = new Date(raw);
        if (!Number.isNaN(parsed.getTime())) {
            return formatDateForUtcPlus3(parsed);
        }
    }

    const parsed = dayjs(raw);
    return parsed.isValid() ? parsed.format('YYYY-MM-DD') : '';
}

function normalizeTime(input) {
    if (input == null || input === '') return '';
    const raw = String(input).trim();
    if (/^\d{2}:\d{2}:\d{2}$/.test(raw)) return raw.slice(0, 5);
    if (/^\d{2}:\d{2}$/.test(raw)) return raw;
    if (looksLikeDateTime(raw)) {
        const parsed = new Date(raw);
        if (!Number.isNaN(parsed.getTime())) {
            return formatTimeForUtcPlus3(parsed);
        }
    }

    const isoTime = raw.match(/T(\d{2}:\d{2})/);
    if (isoTime) return isoTime[1];
    const plainTime = raw.match(/\b(\d{2}:\d{2})(?::\d{2})?\b/);
    if (plainTime) return plainTime[1];
    return raw;
}

function looksLikeDateTime(value) {
    return /T/.test(value) || /[zZ]|[+-]\d{2}:?\d{2}/.test(value);
}

function toUtcPlus3(dateObj) {
    return new Date(dateObj.getTime() + UTC_PLUS_3_OFFSET_MINUTES * 60_000);
}

function formatDateForUtcPlus3(dateObj) {
    const shifted = toUtcPlus3(dateObj);
    const year = shifted.getUTCFullYear();
    const month = String(shifted.getUTCMonth() + 1).padStart(2, '0');
    const day = String(shifted.getUTCDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

function formatTimeForUtcPlus3(dateObj) {
    const shifted = toUtcPlus3(dateObj);
    const hours = String(shifted.getUTCHours()).padStart(2, '0');
    const minutes = String(shifted.getUTCMinutes()).padStart(2, '0');
    return `${hours}:${minutes}`;
}

function getEventsByDate(dateStr, eventsByDateIndex = buildEventsByDateIndex(state.events)) {
    const dayEvents = eventsByDateIndex.get(dateStr) || [];
    return {
        all: dayEvents,
        sure: dayEvents.filter(event => !event.unsure),
        unsure: dayEvents.filter(event => event.unsure)
    };
}

// ===== Rendering =====

function renderGymIcons(dayEvents, dateStr) {
    const uniqueGyms = [...new Set(dayEvents.map(item => item.gym))].slice(0, 4);
    const previousGyms = state.previousCalendarGymsByDate[dateStr] || new Set();
    return `<div class="gym-icons">${uniqueGyms.map(gym => {
        const meta = gymMeta[gym];
        if (!meta || !meta.image) {
            const isNew = !previousGyms.has(gym) ? " is-new" : "";
            return `<span class="gym-icon${isNew}" title="${escapeHtml(gym)}"></span>`;
        }

        const isNew = !previousGyms.has(gym) ? " is-new" : "";
        return `<span class="gym-icon${isNew}" title="${escapeHtml(gym)}"><img src="${encodeURI(meta.image)}" alt="${escapeHtml(gym)}"></span>`;
    }).join('')}</div>`;
}

function renderCalendar() {
    const calendar = document.getElementById('calendar');
    const nextCalendarGymsByDate = {};
    const eventsByDateIndex = buildEventsByDateIndex(state.events);
    calendar.innerHTML = '';

    document.getElementById('monthTitle').innerText =
        state.currentMonth.format('MMMM YYYY').replace(/^./, m => m.toUpperCase());

    const weekdays = ['–ü–Ω','–í—Ç','–°—Ä','–ß—Ç','–ü—Ç','–°–±','–í—Å'];
    weekdays.forEach(d => {
        calendar.innerHTML += `<div class="weekday">${d}</div>`;
    });

    const startOffset = state.currentMonth.startOf('month').isoWeekday() - 1;
    const daysInMonth = state.currentMonth.daysInMonth();

    for (let i=0;i<startOffset;i++) {
        calendar.innerHTML += `<div></div>`;
    }

    for (let d=1; d<=daysInMonth; d++) {
        const dateStr = state.currentMonth.date(d).format('YYYY-MM-DD');
        const { sure: sureEvents, unsure: unsureEvents } = getEventsByDate(dateStr, eventsByDateIndex);
        const hasUnsureOnly = sureEvents.length === 0 && unsureEvents.length > 0;
        nextCalendarGymsByDate[dateStr] = new Set([...new Set(sureEvents.map(item => item.gym))].slice(0, 4));

        const isToday = dayjs().format('YYYY-MM-DD') === dateStr;

        calendar.innerHTML += `
        <div class="day ${isToday?'today':''} ${sureEvents.length?'has-events':''} ${hasUnsureOnly ? 'has-unsure-only' : ''}"
            onpointerdown="openModal('${dateStr}')">
            <div>${d}</div>
            ${sureEvents.length ? renderGymIcons(sureEvents, dateStr) : '<div></div>'}
            <div class="count">${sureEvents.length ? sureEvents.length + ' üë•' : ''}</div>
        </div>`;
    }

    state.previousCalendarGymsByDate = nextCalendarGymsByDate;

}

function openModal(date) {
    state.selectedDate = date;
    document.getElementById('modalDateTitle').innerText =
        dayjs(date).format('DD MMMM YYYY');

    const eventsByDateIndex = buildEventsByDateIndex(state.events);
    const { sure: sureEvents, unsure: unsureEvents } = getEventsByDate(date, eventsByDateIndex);
    const orderedEvents = [...sureEvents, ...unsureEvents];

    const previousModalKeys = state.modalEventKeysByDate[date] || new Set();
    const nextModalKeys = new Set();

    const fingerprintCounts = {};
    document.getElementById('visitsList').innerHTML =
        orderedEvents.length
        ? orderedEvents.map(e => {
            const sameFingerprintCount = (fingerprintCounts[e.fingerprint] || 0) + 1;
            fingerprintCounts[e.fingerprint] = sameFingerprintCount;
            const eventKey = `${e.fingerprint}|${sameFingerprintCount}`;
            nextModalKeys.add(eventKey);
            const isNew = previousModalKeys.has(eventKey) ? '' : ' is-new';
            return `<div class="visit-item${isNew} ${e.unsure ? 'uncertain' : ''}"><div class="visit-text"><b class="visit-name${e.unsure ? ' uncertain' : ''}">${escapeHtml(e.name)}${e.unsure ? ' (?)' : ''}</b> ‚Äì ${escapeHtml(e.gym)}${e.time ? ` (${escapeHtml(e.time)})` : ''}</div>
                <button class="delete-btn" onclick="deleteVisit('${escapeHtml(e.id)}')">–£–¥–∞–ª–∏—Ç—å</button></div>`;
          }).join('')
        : '–ü–æ–∫–∞ –Ω–∏–∫—Ç–æ –Ω–µ –∑–∞–ø–∏—Å–∞–ª—Å—è';

    state.modalEventKeysByDate[date] = nextModalKeys;

    const baseEvent = sureEvents[0] || unsureEvents[0] || null;
    if (baseEvent) {
        setCustomSelectValue('gymSelectUi', 'gymSelect', baseEvent.gym);
        if (baseEvent.time) {
            setCustomSelectValue('visitTimeUi', 'visitTime', baseEvent.time);
        }
    }

    if (state.modalUnlockTimeoutId) {
        clearTimeout(state.modalUnlockTimeoutId);
        state.modalUnlockTimeoutId = null;
    }
    document.body.style.overflow = 'hidden';
    overlayElement.classList.add('open');
    modalElement.classList.add('open');
    lockModalInteraction();
    document.getElementById('visitUncertain').checked = false;
}

function closeModal({ deferUnlock = false } = {}) {
    state.modalInteractionToken += 1;
    state.modalInteractionUnlockedAt = 0;
    modalElement.classList.remove('interaction-locked');
    if (state.modalInteractionTimeoutId) {
        clearTimeout(state.modalInteractionTimeoutId);
        state.modalInteractionTimeoutId = null;
    }

    overlayElement.classList.remove('open');
    modalElement.classList.remove('open');

    const unlockScroll = () => {
        document.body.style.overflow = '';
        state.modalUnlockTimeoutId = null;
    };

    if (state.modalUnlockTimeoutId) {
        clearTimeout(state.modalUnlockTimeoutId);
    }

    if (deferUnlock) {
        state.modalUnlockTimeoutId = setTimeout(unlockScroll, 0);
        return;
    }

    unlockScroll();
}

document.addEventListener('keydown', e=>{
    if(e.key==='Escape') closeModal();
});

// ===== User actions and sync =====

async function submitVisit() {
    const name = (localStorage.getItem('climberName') || '').trim();
    if (!name) return alert('–°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏ –∏–º—è');

    const newEvent = withFingerprint({
        id: `local-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        date: state.selectedDate,
        name,
        gym: document.getElementById('gymSelect').value,
        time: document.getElementById('visitTime').value,
        unsure: document.getElementById('visitUncertain').checked,
        pending: true,
        optimisticCreatedAt: Date.now(),
        row: null
    });

    state.events.push(newEvent);
    persistEvents();
    renderCalendar();
    openModal(state.selectedDate);

    const created = await createVisitOnServer(newEvent);
    if (!created) {
        setEvents(state.events.filter(event => event.id !== newEvent.id));
        persistEvents();
        renderCalendar();
        openModal(state.selectedDate);
        alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑.');
        return;
    }

    await syncChanges();
}

async function createVisitOnServer(newEvent) {
    try {
        const res = await fetch(API_URL, {
            method: 'POST',
            headers: {'Content-Type': 'text/plain;charset=utf-8'},
            body: JSON.stringify({
                date: newEvent.date,
                name: newEvent.unsure ? `${newEvent.name}${UNSURE_MARK}` : newEvent.name,
                gym: newEvent.gym,
                time: newEvent.time,
                unsure: newEvent.unsure
            })
        });
        return res.ok;
    } catch {
        return false;
    }

}

async function deleteVisit(eventId) {
    const target = state.events.find(event => event.id === eventId);
    if (!target) return;

    setEvents(state.events.filter(event => event.id !== eventId));
    state.deletionShadows.push({
        fingerprint: target.fingerprint,
        createdAt: Date.now()
    });
    pruneDeletionShadows();
    persistEvents();
    renderCalendar();
    openModal(state.selectedDate);

    if (!target.row) return;

    try {
        const res = await fetch(API_URL, {
            method: 'POST',
            headers: {'Content-Type': 'text/plain;charset=utf-8'},
            body: JSON.stringify({ action: 'delete', row: target.row })
        });

        if (res.ok) await syncChanges();
    } catch {
        // –ª–æ–∫–∞–ª—å–Ω–∞—è –∑–∞–ø–∏—Å—å —É–∂–µ —É–¥–∞–ª–µ–Ω–∞, –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è
    }

}

function persistEvents() {
    localStorage.setItem(EVENTS_CACHE_KEY, JSON.stringify(state.events));
}

function pruneDeletionShadows(now = Date.now()) {
    state.deletionShadows = state.deletionShadows.filter(item => now - item.createdAt < SHADOW_TTL_MS);
}

function loadCachedEvents() {
    try {
        const raw = localStorage.getItem(EVENTS_CACHE_KEY);
        if (!raw) return false;
        setEvents(normalizeEvents(JSON.parse(raw)));
        renderCalendar();
        return true;
    } catch {
        return false;
    }

}

async function initializeCalendar() {
    const hasCache = loadCachedEvents();
    const serverEvents = await fetchEventsSnapshot();

    if (!serverEvents) {
        if (!hasCache) renderCalendar();
        return;
    }

    reconcileWithServerSnapshot(serverEvents);
}

function reconcileWithServerSnapshot(serverEvents) {
    const mergedEvents = mergeServerWithOptimisticEvents(serverEvents, state.events);
    const serializedCurrent = JSON.stringify(state.events);
    const serializedMerged = JSON.stringify(mergedEvents);
    if (serializedCurrent === serializedMerged) {
        return;
    }

    setEvents(mergedEvents);
    persistEvents();
    renderCalendar();
    if (isModalOpen()) {
        openModal(state.selectedDate);
    }

}

function mergeServerWithOptimisticEvents(serverEvents, currentEvents) {
    const now = Date.now();
    pruneDeletionShadows(now);

    const blockedFingerprints = new Set(state.deletionShadows.map(item => item.fingerprint));
    const filteredServerEvents = serverEvents.filter(event => !blockedFingerprints.has(event.fingerprint));
    const serverFingerprints = new Set(serverEvents.map(event => event.fingerprint));
    const optimisticEvents = currentEvents.filter(event => {
        if (!event.pending || !event.optimisticCreatedAt) return false;
        if (serverFingerprints.has(event.fingerprint)) return false;
        return now - event.optimisticCreatedAt < SHADOW_TTL_MS;
    });

    return [...filteredServerEvents, ...optimisticEvents];
}

async function syncChanges() {
    const serverEvents = await fetchEventsSnapshot();
    if (!serverEvents) return;
    reconcileWithServerSnapshot(serverEvents);
}

function shiftMonthBy(step) {
    const wrap = document.getElementById('calendarWrap');
    const title = document.getElementById('monthTitle');
    wrap.classList.remove('slide-left', 'slide-right');
    title.classList.remove('slide-left', 'slide-right');
    wrap.classList.add(step > 0 ? 'slide-left' : 'slide-right', 'animating');
    title.classList.add(step > 0 ? 'slide-left' : 'slide-right', 'animating');

    state.currentMonth = state.currentMonth.add(step, 'month');
    setTimeout(() => {
        renderCalendar();
        wrap.classList.remove('animating');
        title.classList.remove('animating');
    }, 80);
}

initializeCalendar();
setInterval(syncChanges, SYNC_INTERVAL_MS);
</script>

</body>
</html>
